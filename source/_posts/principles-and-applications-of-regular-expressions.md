---
title: 正则表达式原理及应用
date: 2024-02-15 16:08:28
tags:
    - regular expression
categories: 
    - general
lang: zh-CN
---

# 正则表达式原理及应用

# 什么是正则表达式

- 开篇问题
    
    ```cpp
    // 大家可以猜猜在浏览器输入下面的正则表达式会发生什么
    '=XX================================================'.match(/X(.+)+X/)
    ```
    

## 概念

**正则表达式(Regular Expression)**是强大、便捷、高效的**文本处理工具**。正则表达式本身，加上如同一门袖珍编程语言的**通用模式表示法(general pettern notation)**，赋予使用者描述和分析文本的能力。配合上特定工具提供的额外支持，正则表达式能够添加、删除、分离、叠加、插入和修整各种类型的文本和数据

## 起源

正则表达式的起源可以追溯到神经科学的研究，当时提出了一种用数据方式来描述神经网络的方法，这种描述方法利用一种被称之为正则集合的数学符号来描述模式，后来被称为正则表达式，这种方法后来被Unix之父[Ken Thompson](https://baike.baidu.com/item/Ken%20Thompson/3441433?fromModule=lemma_inlink)应用在了Unix系统的编辑器中，并且最终被引用在了一个非常常见的指令grep上，从这以后正则表达式就开始在计算机领域开枝散叶，有到了许多的应用。目前已知正则表达式能力最强的，是Perl语言。

## 使用举例

### 匹配手机号

```cpp
var myreg = 
	/^(13[0-9]{1}|14[5|7|9]{1}|15[0-3|5-9]{1}
				|166|17[0-3|5-8]{1}|18[0-9]{1}|19[8-9]{1}){1}\d{8}$/;
```

### 密码正则

```cpp
// 最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = 
	/^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
```

# 如何使用

正则表达式的符号集合简单点可以分为普通字符和元字符（特殊字符），有些资料中会把元字符继续细分，比如打印字符、限定符等，这里了解即可，本质上就是使用正则表达式作为模板，使用这种模式匹配指定的字符串返回结果。下面主要讲一下元字符的一些规则。更细节的可以查询相关语言中的正则表达式符号表。

## 基础规则

- 行的起始与结束

```jsx
// 行开始
/^/
// 示例
/^1/.test("1")  // true
/^1/.test("2")  // false
/^1/.test("12") // true

// 行结束
/$/
// 示例
/1$/.test("1")   // true
/1$/.test("12")  // false
/1$/.test("121") // true
```

- 字符组

```jsx
// 中括号内则为字符组
/[]/
// 示例
/[12]/g.test("1")   // true
/[12]/g.test("2")   // true
/[12]/g.test("123") // true
/[12]/g.test("3")   // false

// 可以将字符组看成独立的小匹配模式，其内部的元字符和字符组外部定义就不一样
// 如下，其中的.的含义就完全不一样
/[.]/
/./
// 示例
/[.]/.test(".") // true
/[.]/.test("a") // false
/./.test("a")   // true

// 排除型字符组，需要注意的是排除型字符组匹配时也至少有一个字符存在，所以应该理解为匹配一个非x的字符
/[^x]/
// 示例
/[^a]/.test("")  // false
/[^a]/.test("a") // false
/[^a]/.test("b") // true
```

- 多选结构

```jsx
// 使用|作为or关系
/gr(a|e)y/
// 示例
/gr(a|e)y/.test("gray") // true
/gr(a|e)y/.test("grey") // true
/gr(a|e)y/.test("grby") // false
```

- 忽略大小写

```jsx
// 在各语言中使用方式不一样，但i作为特殊参数（修饰符），一般代表忽略大小写
/Test/i
```

- 单词分界符

单词分界符在各语言中的规定不一样，而且单词的识别也并不完全准确。所以有需要使用的时候按具体语言去查一下资料即可。

```jsx
// JS中的单词分界符示例
/abc\b/.test("abc")     // true
/abc\b/.test("abcb")    // false
/abc\b/.test("abc ber") // true
/abc\b/.test("bc")      // false
```

- 可选项(量词)

```jsx
// 表示?前面的字符是个可选项
/?/
// 示例
/1?/.test("1") // true
/1?/.test("")  // true
/1?/.test("2") // true
```

- 其他量词：重复出现

```jsx
// 出现1个或一个1以上
/+/
// 示例
/1+/.test("2") // false
/1+/.test("1") // true
/1+/.test("")  // false
// 出现任意数量
/*/
// 示例
/1*/.test("")   // true
/1*/.test("1")  // true
/1*/.test("11") // true
/1*/.test("2")  // true
```

- 区间：规定重现次数的范围

```jsx
/{x,y}/
// 示例
/1{1,2}/.test("1")   // true
/1{1,2}/.test("11")  // true
/1{1,2}/.test("")    // false
/1{2}/.test("")      // false
/1{2}/.test("1")     // false
/1{2}/.test("11")    // true
```

- 括号及反向引用(backreference)

```jsx
// 匹配中从左至右第一个括号里的正则会被\1所引用
/(regexp)\1/
// 示例
/(123)\1/.test("123123")         // true
/(123)\1/.test("123")            // false
/(123)(456)\1/.test("123456")    // false
/(123)(456)\1/.test("123456123") // true
```

- 转义

```jsx
// 使用\进行转义，字符组内部无效
/\./
// 示例
/\./.test("1")     // false
/\./.test(".")     // true
/\\./.test("\\.")  // true
/\\./.test("\\")   // false
/[\\.]/.test("\\") // true
```

- 非捕获型括号

```jsx
// 只分组不捕获，简单点说，不占用$n的位置
/(?:……)/
// 示例
/(?:123)\1/.test("123\1") // true
/(?:123)/.test("123")     // true

/(?:123)/.exec("123")
// ['123', index: 0, input: '123', groups: undefined]
/(123)/.exec("123")
// ['123', '123', index: 0, input: '123', groups: undefined]
"123456".replace(/(\d{3})(\d{3})/, '$2, $1')
// '456, 123'
"123456".replace(/(?:\d{3})(\d{3})/, '$2, $1')
// '$2, 456'
```

## 拓展

- 环视功能（断言）

```jsx
// 肯定顺序环视（先行断言）从左往右检查，即从某点能够匹配右侧文本
/(?=)/

// 示例
"1".match(/(?=1)/)
// ['', index: 0, input: '1', groups: undefined]
"21".match(/(?=1)/)
// ['', index: 1, input: '21', groups: undefined]
"21".match(/2(?=1)/)
// ['2', index: 0, input: '21', groups: undefined]
"31".match(/2(?=1)/)
// null
"13".match(/(?=1)3/)
// null
"3".match(/(?=1)3/)
// null

// 肯定逆序环视（后行断言）从右往左检查，即从某点能够匹配左侧文本
/(?<=)/

// 示例
"1".match(/(?<=1)/)
// ['', index: 1, input: '1', groups: undefined]
"1".match(/(?<=1)2/)
// null
"12".match(/(?<=1)2/)
// ['2', index: 1, input: '12', groups: undefined]
"12".match(/(?<=1)/)
// ['', index: 1, input: '12', groups: undefined]

// 否定顺序环视（否定正向查找）从左往右检查，即从某点不能匹配右侧文本
/(?!)/

// 示例
"1".match(/(?!1)/)
// ['', index: 1, input: '1', groups: undefined]
"2".match(/(?!1)/)
// ['', index: 0, input: '2', groups: undefined]
"23".match(/(?!1)/)
// ['', index: 0, input: '23', groups: undefined]
"123".match(/(?!1)/)
// ['', index: 1, input: '123', groups: undefined]
"123".match(/(?!1)2/)
// ['2', index: 1, input: '123', groups: undefined]
"123".match(/(?!1)23/)
// ['23', index: 1, input: '123', groups: undefined]
"123".match(/(?!1)123/)
// null
"213".match(/(?!1)2/)
// ['2', index: 0, input: '213', groups: undefined]
// 否定逆序环视（否定逆向查找）从右往左检查，即从某点不能匹配左侧文本
/(?<!)/

// 示例
"1".match(/(?<!1)/)
// ['', index: 0, input: '1', groups: undefined]
"12".match(/(?<!1)/)
// ['', index: 0, input: '12', groups: undefined]
"212".match(/(?<!1)/)
// ['', index: 0, input: '212', groups: undefined]
"2".match(/(?<!1)/)
// ['', index: 0, input: '2', groups: undefined]
"2".match(/(?<!1)2/)
// ['2', index: 0, input: '2', groups: undefined]
"12".match(/(?<!1)2/)
// null
"21".match(/(?<!1)2/)
// ['2', index: 0, input: '21', groups: undefined]
"123".match(/(?<!1)2/)
// null
```

 环视不会占用字符，简单点来说，可以把环视当作一个标记功能，匹配需要结合是否存在环视能标记的位置和具体的模式两个条件都满足才能成功匹配

- 增强的行锚点匹配模式

```jsx
// 多行搜索，识别字符串中的换行符，并按逻辑行进行正则匹配
/x/m

// 示例
"123\n123".match(/^1/gm)
// (2) ['1', '1']
"123\n123".match(/^1/g)
// ['1']
```

- 其他量词
    - 忽略优先量词（其他量词默认是贪婪的）
    
    ```tsx
    x*?
    x+?
    x??
    x{n}?
    x{n,}?
    x{n,m}?
    
    // 示例
    "<foo> <bar> new </bar> </foo>".match(/<.*>/)
    // ['<foo> <bar> new </bar> </foo>', index: 0, input: '<foo> <bar> new </bar> </foo>', groups: undefined]
    "<foo> <bar> new </bar> </foo>".match(/<.*?>/)
    // ['<foo>', index: 0, input: '<foo> <bar> new </bar> </foo>', groups: undefined]
    ```
    

# 正则表达式原理

正则表达式引擎常见的有两种 ，DFA（确定有穷自动机）和NFA（非确定有限状态自动机）

## 区分引擎类型

- 是否是传统NFA
    - 忽略优先量词是否得到支持，如果支持，基本就能确定是传统型NFA
        
        ```jsx
        'nfa not'.match(/nfa|nfa not/)
        // ['nfa', index: 0, input: 'nfa not', groups: undefined]
        // 所以是传统型NFA
        ```
        
- 区分DFA还是POSIXNFA
    - DFA不支持捕获型括号和回溯
    - 也存在混合型的程序，根据需要选用不同的引擎

```jsx
// 可以在浏览器控制台尝试输入下面这个正则表达式
'=XX================================================'.match(/X(.+)+X/)
```

## 算法解析

### NFA(改写自算法第四版)

```tsx
/**
 * 正则表达式的模式匹配
 * 事实上历代正则表达式的基础算法可以主要分为两类：NFA，DFA
 * NFA：不确定有限状态自动机，使用这种实现的正则表达式支持反向引用等操作
 * DFA：确定有限状态自动机，这里的确定就是可以根据模式提前得知所有的状态，
 * 然后可以使的按字符检索不回退，效率比较高
 * 当前这里使用的是NFA为基础的正则表达式简单实现
 * 注：目前js所使用的正则引擎也是基于NFA的
 */

// 有向图算法
import { Digraph } from "../../Graph/common/Digraph"
// 有向图深度优先遍历
import { DirectedDFS } from "../../Graph/DFS/DirectedDFS"

export class NFA {
    private re: string[]
    private G: Digraph
    private M: number
    constructor(regexp: string) {
        const ops = [] as number[]
        this.re = regexp ? regexp.split('') : []
        this.M = this.re.length
        this.G = new Digraph(this.M + 1)

        // 生成∊-状态有向图
        for (let i = 0; i < this.M; i++) {
            let lp = i
            // 在栈中存入( | 的位置（即状态）
            if (this.re[i] === '(' || this.re[i] == '|') {
                ops.push(i)
            } else if (this.re[i] === ')') {
                const or = ops.pop() as number
                if (this.re[or] === '|') {
										// 如果是|关系，则推出上一次的左括号生成或关系左右的值的状态
                    lp = ops.pop() as number
                    this.G.addEdge(lp, or + 1)
                    this.G.addEdge(or, i)
                } else lp = or
            }
						// 生成一个*指向当前字符（或者上一次捕获的字符开头），
            // 和当前字符指向*的循环的状态
            if (i < this.M - 1 && this.re[i + 1] === '*') {
                this.G.addEdge(lp, i + 1)
                this.G.addEdge(i + 1, lp)
            }
	          // 遇到下面的字符则生成一下由当前字符指向下个字符的状态
            if (this.re[i] === '(' || this.re[i] === '*' || this.re[i] === ')') {
                this.G.addEdge(i, i + 1)
            }
        }
    }

    recognizes(txt: string) {
        let pc = [] as number[]
        let dfs = new DirectedDFS(this.G, 0)
        // 确认初始时（0）∊-状态的可达点
        for (let v = 0; v < this.G.V(); v++) {
            if (dfs.marked(v)) pc.push(v)
        }
        for (let i = 0; i < txt.length; i++) {
            //计算txt[i+1]可能达到的所有NFA状态
            const match = [] as number[]
            for (let v of pc) {
                if (v < this.M) {
                    // 匹配则进入下一个状态
                    if (this.re[v] === txt.charAt(i) || this.re[v] == '.') {
                        match.push(v + 1)
                    }
                }
            }
            pc = []
            // 利用多点可达性，得到状态集合的下一次的所有可达点
            dfs = new DirectedDFS(this.G, match)
            for (let v = 0; v < this.G.V(); v++) {
                if (dfs.marked(v)) pc.push(v)
            }
        }
        for (let v of pc) {
            // 如果可达状态中有一次是到达了最后值，证明匹配成功
            if (v === this.M) return true
        }
        return false
    }
}
```

- 图示

![Untitled](Untitled.png)

总结上面的算法，会发现下面的一些情况

- 表达式主导的，每检查一部分，同时检查当前文本是否匹配表达式的当前部分，如果可以就继续表达式的下一部分，如此继续，直到所有部分都能匹配，则整个表达式能够匹配成功。为何称为表达式主导的，是因为表达式的控制权在不同的元素之间转换，每个文本字符都需要去表达式中获取匹配的状态，直到整个表达式都达到匹配的状态。
- 存在回溯：从代码中可以看出，存在量词、多选结构的时候，会需要记录不同分支的状态，留到某分支不匹配的时候去回溯匹配。当所有可能的途径都尝试完之后才会确认匹配失败

### DFA算法

- DFA图示（下面的图本身是用于子字符串搜索的，不准确，只是用来简单的表达下DFA的含义）

![Untitled](Untitled1.png)

- 文本主导的，根据文本会得到每个字符所对应的所有的可能的对应位置状态
    
    ![Untitled](Untitled2.png)
    

### 算法对比

可以看到，一般情况下DFA相对比较快。

这是因为NFA的匹配过程中，目标文本中的某个字符可能会被正则表达式重复检测，即使能够匹配，也可能需要多次应用，直到整个表达式都被匹配过为止。

而DFA每个已经匹配的字符只会被检测一次，因为引擎已经同时记录了所有可能的匹配状态

但NFA可以提供DFA没有的功能，比如捕获、环视等等

# 打造高效的正则表达式

**注：优先跟正则表达式引擎的实现有很大的关系，所以下面只是提供一些示范，但并不是所有的引擎都会支持相同的优化，但通常按优化的写法不会有太大的问题，只是不会有性能上的明显改进而已**

基于NFA的正则表达式，细微的改变就会引起匹配结果和方式的重大变化，所以希望用好正则表达式，就需要指导如何打造高效的正则表达式及调试正则表达式。另外，**提高效率的关键在于深入理解回溯的概念**。

- 考虑好`.*`进行匹配时可能出现的情况会更复杂，所以会导致更多的回溯，所以表达式可以写的更加的具体
- 多选结构会导致效率问题
    - 匹配优先的话，匹配没成功会回溯到当前位置进行下一个选项的匹配，就会导致每个没匹配的位置都需要把多选结构匹配完，导致出现大量的回溯
- 不应该过度依赖正则表达式，结合语言逻辑+正则表达式来减轻正则匹配错误的压力是比较好的。

### 常识性优化

- 避免重新编译
    - 即提前定义相同的正则表达式，避免在循环中重复编译正则表达式（我们直到正则表达式是需要提前编译成状态机的）
- 使用非捕获型括号
    - 减少捕获需要的时间
    - 减少回溯成本
- 不要滥用括号
- 不要滥用字符组
    - 处理字符组也是存在代价的，没必要使用字符组的时候就不要使用，可以通过区分大小写、转义等实现相同的功能
- 使用起始锚点
    - 配合锚点，特别是以.*开头的正则表达式配合起始锚点，可以节省大量不必要的工作

### 将文本独立出来

- 从量词中提取必须的元素
- 提取多选结构开头的必须元素
    
    ```tsx
    (?:this|that) -> th(?:is|at)
    ```
    

### 将锚点独立出来

- 在表达式前面独立出^和\G
    - 这里可能跟不同的引擎实现有关系，关键看引擎对规则识别的优化，但通常下面这种会更具备优势
    
    ```tsx
    ^(?:abc|123) -> ^abc|^123
    ```
    
- 在表达式末尾独立出$
    - 同上

### 拆分正则表达式

 有些时候运用多的小的正则表达式比一个大的正则表达式快得多

把一个复杂的大正则表达式切分为多个小正则表达，有些小正则表达式已经可以筛选掉大量的情况，而如果作为一个大的复杂正则表达式，即增加了理解的成本，同时也可能会导致大量的回溯和分支产生性能问题

### 使用固化分组和占有优先量词

 本质上就是减少回溯，因为这两个特殊语法都可以直接**抛弃备用状态**

### 主导引擎的匹配

- 将最可能匹配的多选分支放在前头
- 将结尾部分分散到多选结构内（不是很建议使用，因为这里要看具体实现，且同提取结尾元字符的优化有点冲突）

**以前两点的优化主要目的就是更快的匹配成功、或是失败**。

### 消除循环

这里的循环指的是如`(this|that……)*`这样的结构，查看NFA简易算法的代码可以知道，这种结构是会造成量词和多选分支之间不断的循环的

书上讲的消除循环的内容比较具体，我觉得总结来说，就是考虑具体实现使得写的正则表达式能早点匹配结束退出，而不是继续尝试下一种可能即可。具体的实现需要经验来支撑。

# 项目中的代码优化的示例

```tsx
/^[a-zA-Z]([a-zA-Z]|-){0,54}[a-zA-Z]$/
->
/^[a-zA-Z](?:[a-zA-Z]|-){0,54}[a-zA-Z]$/
->
/^[a-zA-Z](?:[-a-zA-Z]){0,54}[a-zA-Z]$/
```