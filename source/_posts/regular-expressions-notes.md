---
title: 正则表达式笔记
date: 2024-02-15 16:12:45
tags:
    - regular expression
categories: 
    - general
lang: zh-CN
---

# 正则表达式笔记

## 目录

## 一、基本概念

**正则表达式(Regular Expression)**是强大、便捷、高效的**文本处理工具**。正则表达式本身，加上如同一门袖珍编程语言的**通用模式表示法(general pettern notation)**，赋予使用者描述和分析文本的能力。配合上特定工具提供的额外支持，正则表达式能够添加、删除、分离、叠加、插入和修整各种类型的文本和数据。

> My reason to learn
> 
> 
> 在进行rollup插件开发的时候，发现自身对正则表达式理解过于浅薄，而若能掌握深入的正则知识能极大的提升对code进行处理的能力。
> 

### 1. 基础知识

- 行的起始与结束

```jsx
// 行开始/^/// 行结束/$/
```

- 字符组

```jsx
// 中括号内则为字符组/[]/// 可以将字符组看成独立的小匹配模式，其内部的元字符和字符组外部定义就不一样// 如下，其中的.的含义就完全不一样/[.]//./// 排除型字符组，需要注意的是排除型字符组匹配时也至少有一个字符存在，所以应该理解为匹配一个非x的字符/[^x]/
```

- 多选结构

```jsx
// 使用|作为or关系/gr(a|e)y/
```

- 忽略大小写

```jsx
// 在各语言中使用方式不一样，但i作为特殊参数（修饰符），一般代表忽略大小写/Test/i
```

- 单词分界符

​ 单词分界符在各语言中的规定不一样，而且单词的识别也并不完全准确。所以有需要使用的时候按具体语言去查一下资料即可。

- 可选项(量词)

```jsx
// 表示?前面的字符是个可选项/?/
```

- 其他量词：重复出现

```jsx
/+//*/
```

- 区间：规定重现次数的范围

```jsx
/{x,y}/
```

- 括号及反向引用(backreference)

```jsx
// 匹配中从左至右第一个括号里的正则会被\1所引用/(regexp)\1/
```

- 转义

```jsx
// 使用\进行转义，字符组内部无效/\./
```

- 非捕获型括号

```jsx
// 只分组不捕获，简单点说，不占用$n的位置/(?:……)/
```

### 2. 拓展

- 环视功能

```jsx
// 肯定顺序环视（先行断言）从左往右检查即从某点能够匹配右侧文本/(?=)/// 肯定逆序环视（后行断言）从右往左检查，即从某点能够匹配左侧文本/(?<=)/// 否定顺序环视（否定正向查找）从左往右检查，即从某点不能匹配右侧文本/(?!)/// 否定逆序环视（否定逆向查找）从右往左检查，即从某点不能匹配左侧文本/(?<!)/
```

​ 环视不会占用字符，简单点来说，可以把环视当作一个标记功能，匹配需要结合是否存在环视能标记的位置和具体的模式两个条件都满足才能成功匹配

- 增强的行锚点匹配模式

```jsx
// 多行搜索，识别字符串中的换行符，并按逻辑行进行正则匹配/x/m
```

## 二、正则表达式的特性与流派概览

### 1. 正则表达式的起源(略)

### 2. 正则表达式的注意事项和处理方式

- 集成式(integrated)
- 程序式(procedural)
- 面向对象式(object-oriented)

### 3. 字符串，字符编码和匹配模式

- **作为正则表达式的字符串**

​ 使用字符串作为正则表达式使用时，因为各类编程语言中对字符串也有元字符的规定，特别是一些需要转义的字符，会影响最终正则引擎的解析。

​ 无论规定如何，我们在使用时都不要忘记考虑“在编程语言的字符串处理结束之后，正则引擎接收到的是什么”

- **字符编码**
    - 编码的支持程度
        - 程序能够识别这种编码吗？
        - 程序如何决定采用那种编码来处理这些数据
        - 正则表达式对这种编码的支持程度如何
        - 是否能够支持多字节字符
        - ，包括特殊字符
        - 程序是否会拓展对字符组的解释
        - 不区分大小写的匹配是否能对所有字符有效
- **Unicode**
    - 字符，还是组合字符序列
    - 用多个代码点表示同一个字符
- **正则模式与匹配模式**
    - 不区分大小写的匹配模式
    - 宽松排列和注释模式
    - 点号通配模式（单行模式）
        - 通常，点号不能匹配换行符
        - /s 修饰符代表单行文本模式，虽然好像跟多行对应，但事实这个模式只是说点号可以通配换行符
    - 增强的行锚点模式（多行文本模式）
        - 这个模式其实对应的是修改^和$的匹配规则
    - 文字文本模式

### 4.分组，捕获，条件判断和控制

- 捕获/分组括号：(……)和\1，\2，……
- 仅用于分组的括号：(?:……)
- 命名捕获：(?<Name>……)，**有很多实现不支持**
- 固化分组：(?>……)
- 多选结构（分支结构，或）：低优先级
- 条件判断：(?if then |else)
- 匹配优先量词：*、+、?、{num, num}
- 区间：{min, max}
- 忽略优先量词（即所谓的非贪婪匹配）：*?、+?、??、{num, num}?
- 占有优先量词：*+、++、?+、{num, num}+

## 三、表达式的匹配原理

### 1. 引擎

- DFA
- NFA

1.2 测试引擎

- 是否是传统NFA
    - 支持忽略优先量词一般就是传统NFA
- 区分DFA和POSIX NFA
    - DFA不支持捕获型括号和回溯
    - 也存在两种的混合型

### 2. 匹配的基础

### 2.1 规则1:优先选择最左端的匹配结果

### 2.2 规则2:标准量词是匹配优先的

- 过度的匹配优先：优先匹配的归还，可以归还的会给必须匹配的让步归还出一些字符来
- 先来先服务

### 3. 表达式主导与文本主导

- NFA引擎：表达式主导

核心就是非确定型有限自动状态机

- DFA引擎：文本主导

核心是确定型优先自动状态机

也是因为上面两者的这种区别，DFA通常比NFA要快，其以文本主导，所以表达式的写法一般不影响得到结果的效率，而NFC由表达式主导控制，表达式的写法就变得非常重要。其中的关键就在于DFA是确定型的，其提前构造记录了每个字符匹配和不匹配的所有状态。

### 4. 回溯

- 两个要点
    - 如果需要在“进行尝试”和“跳过尝试”之间选择，对于匹配优先量词，引擎会优先选择“进行尝试”，而对于忽略优先量词，会选择“跳过尝试”
    - 距离当前最近储存的选项就是当本地失败强制回溯时返回的（LIFO，栈结构）
- 备用状态
    - 保存了两个状态
        - 正则表达式中的位置
        - 未尝试的分支在字符串中的位置
- 回溯与匹配优先

## 四、正则表达式的实用技巧

### 1. 正则表达式的平衡法则

好的正则表达式必须在这些方面求得平衡：

- 只匹配期望的文本，排除不期望的文本
- 必须易于控制和理解
- 如果使用NFA引擎，必须保证效率（如果能够匹配，必须很快的返回匹配结果，如果不能匹配，应该在尽可能短的时间内报告匹配失败）

## 五、打造高效的正则表达式

基于NFA的正则表达式，细微的改变就会引起匹配结果和方式的重大变化，所以希望用好正则表达式，就需要指导如何打造高效的正则表达式及调试正则表达式。另外，**提高效率的关键在于深入理解回溯的概念**。

- 考虑好`.*`进行匹配时可能出现的情况会更复杂，所以会导致更多的回溯，所以表达式可以写的更加的具体
- 多选结构会导致效率问题
    - 匹配优先的话，匹配没成功会回溯到当前位置进行下一个选项的匹配，就会导致每个没匹配的位置都需要把多选结构匹配完，导致出现大量的回溯
- 可以参考引擎算法的简易实现，来更好的理解正则匹配的原理
    - [NFA算法简易实现](https://github.com/ylinH-git/algorithm-ts/blob/main/String/search/NFA.ts)
    - [DFA算法简易实现](https://github.com/ylinH-git/algorithm-ts/blob/main/String/search/KMP.ts)
- 不应该过度依赖正则表达式，结合语言逻辑+正则表达式来减轻正则匹配错误的压力是比较好的。

### 常识性优化

- 避免重新编译
- 使用非捕获型括号
- 不要滥用括号
- 不要滥用字符组
- 使用起始锚点

### 将文本独立出来

- 从量词中提取必须的元素
- 提取多选结构开头的必须元素

### 将锚点独立出来

- 在表达式前面独立出^和\G
- 在表达式末尾独立出$

### 拆分正则表达式

​ 有些时候运用多的小的正则表达式比一个大的正则表达式快得多

### 使用固化分组和占有优先量词

​ 本质上就是减少回溯

### 主导引擎的匹配

- 将最可能匹配的多选分支放在前头
- 将结尾部分分散到多选结构内

### 消除循环

这里的循环指的是如`(this|that……)*`这样的结构，查看NFA简易算法的代码可以知道，这种结构是会造成量词和多选分支之间不断的循环的

书上讲的消除循环的内容比较具体，我觉得总结来说，就是考虑具体实现使得写的正则表达式能早点匹配结束退出，而不是继续尝试下一种可能即可。具体的实现需要经验来支撑。

[正则表达式原理及应用](/2024/02/15/principles-and-applications-of-regular-expressions/)